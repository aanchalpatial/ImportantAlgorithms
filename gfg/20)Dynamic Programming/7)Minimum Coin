//Given an infinite supply of certain coins. Find the minimum number of coins required to make given value.

//Greedy approach of choosing largest value coin won't work here. For example : Value = 11 & coins = {9, 6, 5, 1}

#include <bits/stdc++.h>
using namespace std;

//Naive recursion
int minCount(int coins[], int n, int sum){
    if(sum==0) return 0;
    
    int result = INT_MAX;
    for(int i=0;i<n;++i){
        if(coins[i]<=sum) {
            int curr = minCount(coins, n, sum-coins[i]);
            if(curr!=INT_MAX) result = min(result, 1 + curr);
        }
    }
    return result;
}

int minCount_tabulation(int coins[], int n, int sum){   //O(sum*n)
    int tab[sum+1]; //tab[i] represents minimum coins required to make sum i
    tab[0] = 0; //base case : minimum number of coins required to make sum 0 is 0
    for(int i=1;i<=sum;++i) tab[i] = INT_MAX;
    
    for(int i=1;i<=sum;++i){
        for(int j=0;j<n;++j){
            if(coins[j]<=i){
                int curr = tab[i-coins[j]];
                if(curr!=INT_MAX) tab[i] = min(tab[i], 1+curr);    
            }
        }
    }
    return tab[sum];
}

int main() {
    int coins[] = {9, 6, 5, 1};
    int sum = 11;
    int n = sizeof(coins)/sizeof(coins[0]);
    
    int result = minCount_tabulation(coins, n, sum);
    //returns INT_MAX if it is not possible to make given sum with given set of coins
    if(result!=INT_MAX) cout<<result<<endl;
    else cout<<"-1"<<endl;
	return 0;
}






