//Given an infinite supply of certain coins. Find number of different combinations of coins which leads to given sum. 
/*OR
Given a value N, if we want to make change for N cents, and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins,
how many ways can we make the change? The order of coins doesnâ€™t matter.
*/

#include <bits/stdc++.h>
using namespace std;

//Naive recursion
int getCount(int coins[], int sum, int n){      //Time : exponential
    //Base cases
    if(sum==0) return 1;
    if(n==0) return 0;
    
    //Case 1 : when current coin i.e coins[n-1] is not included
    int result = getCount(coins, sum, n-1);
    //Case 2 : Current coin is included
    //only if value of current coin is less than or equal to current sum i.e i
    if(coins[n-1]<=sum) result += getCount(coins, sum-coins[n-1], n);
    return result;
}

//DP solution with tabulation
int getCount_tabulation(int coins[], int sum, int n){   //O(sum*n)
    int tab[sum+1][n+1];    //used for tabulation
    //Note :- int tab[n+1][sum+1]; will not lead to correct result
    
    //Base Case
    for(int i=0;i<=n;++i) tab[0][i] = 1;  //when sum is 0
    for(int i=1;i<=sum;++i) tab[i][0] = 0;  //when number of coins is 0
    
    for(int i=1;i<=sum;++i){
        for(int j=1;j<=n;++j){
            //Case 1 : when current coin i.e coins[j-1] is not included
            tab[i][j] = tab[i][j-1];
            //Case 2 : Current coin is included
            //only if value of current coin is less than or equal to current sum i.e i
            if(coins[j-1]<=i) tab[i][j] += tab[i-coins[j-1]][j];
        }
    }
    
    // for(int i=0;i<=sum;++i){
    //     for(int j=0;j<=n;++j){
    //         cout<<tab[i][j]<<" ";
    //     }
    //     cout<<endl;
    // }
    
    return tab[sum][n];
}


int main() {
    
    int coins[] = {1, 2, 3};
    int n = sizeof(coins)/sizeof(coins[0]);
    int sum = 4;
    cout<<get Count_tabulation(coins, sum, n)<<endl;
	return 0;
}


//APPLICATIONS :- 
//Problem 1 is not of coin change but used to show difference between 2 problems when order DOES & DOESN'T matter.
//Note **differences** between Problem 1 & Problem 2 i.e Coin Change Method is used only when order doesn't matter.

/*1)
There are N stairs, a person standing at the bottom wants to reach the top. The person can climb either 1 stair or 2 stairs
at a time. Count the number of ways, the person can reach the top (order does matter).
*/
long long countWays(int m){
    
    long long dp[m+1];
    dp[0] = 1;
    
    
    for(int i=1;i<=m;++i){
        dp[i] = dp[i-1];
        if(i-2>=0) dp[i] += dp[i-2];
        dp[i] %= mod;
    }
    
    return dp[m];
    
}

/*2)
There are N stairs, and a person standing at the bottom wants to reach the top. The person can climb either 
1 stair or 2 stairs at a time. Count the number of ways, the person can reach the top (order does not matter).
Note: Order does not matter means for n=4 {1 2 1},{2 1 1},{1 1 2} are considered same.
*/
long long countWays(int m){
    // your code here
    int coins[2] = {1, 2};
    
    long long dp[m+1][3];
    for(int i=0;i<=2;++i) dp[0][i] = 1;
    for(int i=1;i<=m;++i) dp[i][0] = 0;
    
    for(int i=1;i<=m;++i){
        for(int j=1;j<=2;++j){
            dp[i][j] = dp[i][j-1];
            if(coins[j-1]<=i) dp[i][j] += dp[i-coins[j-1]][j];
        }
    }
    
    return dp[m][2];
}

/*3) 
Given a positive integer N, the task is to find the number of different ways in which N can be written as a 
sum of two or more positive integers.
*/

int countWays(int n)
{
    // your code here
    int sum = n;
    int coins[n-1];
    for(int i=0;i<n-1;++i) coins[i] = i+1;
    int c = n-1;
    
    //dp[i][j] represents number of ways to make i with coins from 0 to j
    int dp[sum+1][c+1];
    //Base cases : 
    for(int i=0;i<=c;++i) dp[0][i] = 1;
    for(int i=1;i<=sum;++i) dp[i][0] = 0;
    
    for(int i=1;i<=sum;++i){
        for(int j=1;j<=c;++j){
            //Case 1 : 
            dp[i][j] = dp[i][j-1]%mod;
            //Case 2 :
            if(coins[j-1]<=i) dp[i][j] += (dp[i-coins[j-1]][j]%mod);
            dp[i][j] %= mod;
        }
    }
    
    return dp[sum][c];
    
}









