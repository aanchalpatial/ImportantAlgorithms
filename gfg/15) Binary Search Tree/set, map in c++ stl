//1) **set** is a balanced BST implemented using Red Black trees
//elements of set are ORDERED & DISTINCT
//set<data_type> set_name;

//begin(), end(), rbegin(), rend(), cbegin(), cend(), crbegin(), crend(), size(), empty are O(1)
//count(), insert(), find(), lower_bound(), upper_bound(), erase(value) are O(log n)
//erase(iterator) is amortized O(1)

//Applications: Maintain sorted stream of data
                Doubly ended priority queue
                
 

                
//2) **map** is a balanced BST implemented using Red Black trees
//each element of map is a pair, elements of map are ORDERED(according to key) & DISTINCT i.e all keys are unique
//map<data_type_of_key, data_type_of_value> map_name;

// m.at(key) vs m[key] : both are used access element of map with certain key, but if key is not present in map [] operator inserts
//an element with given key and value 0 into the map whereas at() operator throw an out of range exception

//time complexity of functions of map are same as in set

//Applications: Maintain sorted stream of data with (key, value) pair
                Doubly ended priority queue  with (key, value) pair

// count(key) vs find(key) : find() returns a reference to the element of map where as count() returns the number of times a certain key 
//is present in map but since keys are distinct in map , count actually returns 0 or 1.

//lower_bound() vs upper_bound : 
//Lower bound: first element that is greater-or-equal. Upper bound: first element that is strictly greater.

//In erase() function argument can either be an ITERATOR or KEY or RANGE

