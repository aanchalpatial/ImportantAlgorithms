/*
       1
    /     \
   2       3
  /  \    / \
 4    5  6   7

Left View of above Tree will be: 1, 2, 4
Right View of above Tree will be: 1, 3, 7
Top View of above Tree will be: 4, 2, 1, 3, 7
Bottom View of above Tree will be: 4, 5, 6, 7
*/



//1) Print LEFT VIEW of binary tree : 2 versions
//left view means left most node(can be a left child or a right child) of every level in binary tree
//Recursive version : O(n) time & O(h) space , preferred for perfect trees
int maxLevel = 0;
void leftViewRecursive(Node *root, int level){    //initial value of level is 1
    //Uses preorder traversal
    if(root!=NULL){
        if(maxLevel<level){     //avoid printing anything except left most node
            cout<<root->key<<endl;
            maxLevel = level;
        }
        leftViewRecursive(root->left, level+1);
        leftViewRecursive(root->right, level+1);
    }
}
//Iterative Version: BFS, O(n) time & O(w) space , preferred for skewed trees
void leftViewIterative(Node *root){
    //uses line by line bfs traversal
    if(root!=NULL){
        queue<Node *> q;
        q.push(root);
        while(!q.empty()){
            int cnt = q.size();
            for(int i=0;i<cnt;++i){
                Node *temp = q.front();
                q.pop();
                if(i==0){       //avoid printing anything except left most node
                    cout<<temp->key<<" ";
                }
                if(temp->left!=NULL){
                    q.push(temp->left);
                }
                if(temp->right!=NULL){
                    q.push(temp->right);
                }
                
            }
            cout<<endl;
        }
    }
}



//2) Print LEFT VIEW of binary tree : 2 versions
//left view means right most node(can be a left child or a right child) of every level in binary tree
void leftViewIterative(Node *root){
    //uses line by line bfs traversal
    if(root!=NULL){
        queue<Node *> q;
        q.push(root);
        while(!q.empty()){
            int cnt = q.size();
            for(int i=0;i<cnt;++i){
                Node *temp = q.front();
                q.pop();
                if(i==cnt-1){       //avoid printing anything except right most node
                    cout<<temp->key<<" ";
                }
                if(temp->left!=NULL){
                    q.push(temp->left);
                }
                if(temp->right!=NULL){
                    q.push(temp->right);
                }
                
            }
            cout<<endl;
        }
    }
}


//3) Print TOP VIEW of binary tree
//Top view of a binary tree is the set of nodes visible when the tree is viewed from the top
        1
      /   \
    2       3
      \   
        4  
          \
            5
             \
               6
Top view of the above binary tree is
2 1 3 6
//The output nodes can be printed in any order. Expected time complexity is O(n)
/*HINT:
A node x is there in output if x is the topmost node at its horizontal distance. Horizontal distance of left child of a node x is
equal to horizontal distance of x minus 1, and that of right child is horizontal distance of x plus 1.
*/
void printTopView(Node *root){
    unordered_map<int, int> m;        //key: level of node, value: value of node
    queue<pair<Node *,int>> q;
    q.push(make_pair(root,0));
    while(!q.empty()){
        int cnt = q.size();
        for(int i=0;i<cnt;++i){
            Node *temp = q.front().first;
            int level = q.front().second;
            q.pop();
            if(m.find(horizontalDistance)==m.end()) {
                m[horizontalDistance] = temp->key;
            }
            
            if(temp->left!=NULL) q.push(make_pair(temp->left, horizontalDistance-1));
            if(temp->right!=NULL) q.push(make_pair(temp->right, horizontalDistance+1));
        }
    }
    
    for(auto i: m) cout<<i.second<<" ";
    cout<<endl;
}


//3) Print BOTTOM VIEW of binary tree
//A node x is there in output if x is the bottom most instead of the top most node at its horizontal distance.
/*The process of printing the bottom view is almost the same as that of top view with a little modification that while storing 
the node's data along with a particular horizontal distance in the map, keep updating the node's data in the map for a
particular horizontal distance so that the map contains the last node appearing with a particular horizontal distance instead of first.
*/
void printBottomView(Node *root){
    unordered_map<int, int> m;        //key: level of node, value: value of node
    queue<pair<Node *,int>> q;
    q.push(make_pair(root,0));
    while(!q.empty()){
        int cnt = q.size();
        for(int i=0;i<cnt;++i){
            Node *temp = q.front().first;
            int horizontalDistance = q.front().second;
            q.pop();
            m[horizontalDistance] = temp->key;   //keep updating so it stores the bottomost node a 
            
            if(temp->left!=NULL) q.push(make_pair(temp->left, horizontalDistance-1));
            if(temp->right!=NULL) q.push(make_pair(temp->right, horizontalDistance+1));
        }
    }
    
    for(auto i: m) cout<<i.second<<" ";
    cout<<endl;
}

int main() {
    Node *root = new Node(10);
    root->right = new Node(30);
    root->left = new Node(20);
    root->left->right = new Node(40);
    root->left->right->right = new Node(50);
    root->left->right->right->right = new Node(60);
    
    //printTopView(root);
    printBottomView(root);
    
	return 0;
}
