#include <bits/stdc++.h>
using namespace std;

int main()
{
    /*
    The result of logical operators (&&, || and !) is either 0 or 1, but bitwise operators return an integer value.
    Shift Operations must not be used with negative numbers.
    Java doesn't support unsigned.
    Java has one extra bitwise operator i.e unsigned right shift operator ">>>"       
    */
    
    //A number −x in a signed representation equals the number 2^n − x in an unsigned representation
    int x=-43;
    unsigned int y=x;
    cout<<y<<endl;
    
    // ~x = −x − 1
    cout<<~29<<endl;
    //2's complement of a number is 1's complement +1
    int d=33;
    int e=(~d+1);
    
    
    // =======================================**  APPLICATIONS    **=====================================================
    
    //1)
            //CHECK EVEN/ODD
            if(x&1) cout<<"odd";
            else cout<<"even";
    
    
    //2)
            //MULTIPLY x BY 2^k :   x<<k
            //DIVIDE x BY 2^k + use floor func on division result   :   x>>k
            //Find log base 2 of a 32 bit integer : We right shift x repeatedly until it becomes 0
            int log2(int x) 
            { 
            int res = 0; 
            while (x >>= 1) 
                res++; 
            return res; }
            //FIND MOST SIGNIFICANT BIT IN GIVEN NUMBER : log2(N) gives the position of the MSB in N.
    
    
    
    //3)MODIFY PARTICULAR BITS
            
            //set kth bit to 1          :     x = x|(1<<k)
            // set kth bit to 0         :     x = x&~(1<<k)
            //invert kth bit            :     x = x^(1<<k)
    
    
    //4)
    //ACCESS Kth BIT(from right) : x&(1<<k)

            //BIT REPRESENTATION OF AN INTEGER
            int h=50;
            for(int i=31;i>=0;--i){
                if(h&(1<<i)) cout<<"1";
                else cout<<"0";
            }

            //GENERATE POWER SET
            string str = "ABC";
            int n = str.size();
            for(int i=0;i<pow(2,n);++i){
                for(int j=0;i<n;++i){
                    if( i&(1<<j) != 0 ) cout<<str[j];
                    }}
                    
    
    
    //5)
    //INVERT LOWEST SET BIT :   x = x&(x-1)

            //X IS A POWER OF 2 IF
            if( x&(x-1) == 0 ) cout<<"Yes";     //doesn't work if x = 0, check separately

            //NUMBER OF ONE BITS ( Brian Karnighan Algorithm, 0(no of set bits) )
            while(x>0){
                x = x&(x-1)
                ++count;
            }



    //6)
    //BUILT IN FUNCTIONS
            cout<<__builtin_clz(h)<<endl;               // the number of zeros at the beginning of the number
            cout<<__builtin_ctz(h)<<endl;               //the number of zeros at the end of the number
            cout<<__builtin_popcount(h)<<endl;          //the number of ones in the number
            cout<<__builtin_parity(h)<<endl;            //the parity (even or odd) of the number of ones
    
    //7)
    //find the Maximum AND Value generated by any pair of the element from the array.    "LEFT"
    //https://www.geeksforgeeks.org/maximum-value-pair-array/
    
    //8)
    //Binary to Gray Code : int x = n^(n>>1);
    //Gray Code to Binary : 
    int b=0;
    for(;n;n=n>>1)
        b^=n;
    cout<<b;
   
    
    
    return 0;
}
