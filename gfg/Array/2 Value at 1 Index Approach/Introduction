STORING 2 VALUES AT 1 INDEX 
This approach is used in questions where we have rearrange elements of an array in O(1) space

Whenever a question states that values in array are in range 0 to n-1 , it gives us some kind of hint to use above approach
to solve given question in O(1)

/*APPROACH :
We would be discussing a more generalised approach here, which can be used for other type of Rearranging problems.

For Rearranging array, we need to store a new value at the position of old value, but do not want to lose the old value too.
Also, we cannot use extra space for this operation (else it would not be Rearrangement and is very easy to execute).

Here, We will store both new value and old value at same position. But how is that possible..?? (No, I am not using pair)

Here, We will use the formula Dividend = Divisor * Quotient + Remainder
where      

           Divisor = a value greater than any element in array
Note : when in question it is stated that every element in array is in range either 0 to n-1 or 1 to n then we can
consider above divisor to size of array or size of array + 1 respectively, since it will be greater than any element in array
           
           Quotient = New number at index i after rearrangement
           Remainder = Old Number at index i before rearrangement
           Dividend = Number stored at index i

While Traversing the array, we will Look for the value at arr[arr[i]] (which is to be stored at index i),
multiply it with Divisor (size of array), and add the old value present at arr[i] to it.
Divisor is a value which is higher then values in array (in this case n - size of array, as array elements are between 0 to n-1)

New Value =  Number stored at i / Divisor
Old Value = Number stored at i % Divisor
*/

/*IN SIMPLE WORDS : 

     we will use a mathematics trick to store 2 values at one index
     say we have to store x & y at index i of arr
     then first we have to find an element (Which is greater than every element of array) x & y say z
     then arr[i] = x + y*z, then arr[i]%z will give x &
     arr[i]/z will give y
     
*/



//APPLICATION 1 :  Above approach is used to make mergesort in place :
//Check here : Line 50 of :- https://github.com/ap0996/ImportantAlgorithms/blob/master/gfg/7)%20Sorting/Merge%20Sort%20and%20its%20Merge%20Function


//Problem 1 : 
//Given an array A[] of N positive integers which can contain integers from 1 to N where elements can be
//repeated or can be absent from the array. Your task is to count frequency of all elements from 1 to N.

// *** Note: Expected time complexity is O(n) with O(1) extra space. *** 

void printfrequency(int arr[], int n)
{ 

	// naive is : O(n) time & O(n) space
	
	//method 2 : 2 values at 1 index appraoch
	//O(n) time & O(1) space
 
  	int M = n+5;	//any value which is guaranteed to greater than every element of array
	
	for(int i=0;i<n;++i) arr[i] *= M;
	
	for(int i=0;i<n;++i){
	    int ele = arr[i]/M;
	    int index = ele-1;
	    ++arr[index];
	    
	}
	for(int i=0;i<n;++i) cout<<arr[i]%M<<" ";
  
  //method 3 :
  //O(n) time & O(1) space
  /*
  1)  Subtract 1 from every element so that the elements
    become in range from 0 to n-1
    for (int j =0; j < n; j++)
        arr[j] = arr[j]-1;

2)  Use every element arr[i] as index and add 'n' to
    element present at arr[i]%n to keep track of count of
    occurrences of arr[i]
    for (int i=0; i < n; i++)
        arr[arr[i]%n] = arr[arr[i]%n] + n;

3)  To print counts, simply print the number of times n
    was added at index corresponding to every element
    for (int i =0; i < n; i++)
        print "(i + 1) -> arr[i] " 
  */
}



//Problem 2 : Given an array arr[] of size N where every element is in range from 0 to n-1. Rearrange the given array so that
//arr[i] becomes arr[arr[i]]. This should be done with O(1) extra space.

void arrange(long long arr[], int n) {
    int M = n+5;	//any value which is guaranteed to greater than every element of array
    
    for(int i=0;i<n;++i) arr[i] *= M;
    
    for(int i=0;i<n;++i){
        int ele = arr[i]/M;
        arr[i] = arr[i] + arr[ele]/M;
    }
    for(int i=0;i<n;++i) arr[i] = arr[i]%M;
}



/*Problem 3
 Given a sorted array of positive integers. Your task is to rearrange  the array elements alternatively i.e first 
element should be max value, second should be min value, third should be second max, fourth should be second min and so on.
Note: O(1) extra space is allowed. 
*/
void rearrange(int *arr, int n) 
{ 
	int max = arr[n-1]+1;    //greater than any value present in array
	// Your code here
	int k = 0,m = n-1;
	for(int i=0;i<n;++i){
	    if(i%2 == 0){
	        arr[i] = ( (arr[m-(i/2)]%max) * max ) + arr[i];
	    }else{
	        arr[i] = ( (arr[k+(i/2)]%max) * max ) + arr[i];
	    }
	    //printArr(arr,n);	
	}
	for(int i=0;i<n;++i){
	    arr[i] = arr[i]/max;
	}
}


//Problem 4 : Find duplicates in an array
/*
Given an array a[] of size n which contains elements from 0 to n-1, your task is to print the duplicate elements
of the given array. If no duplicate element is found print -1.
Note : if a duplicate element occurs k time , you just have to print it once
.The order of the output should be in sorted order.
*/
// *****  Auxiliary Space must be O(1) and Time complexity must be O(n). *****
void printDuplicates(int a[], int n) {
    
    //method 1 : sorting
    //O(nlogn) time & O(1) space
    // sort(a, a+n);
    // bool duplicateFlag = false;
    // for(int i=0;i<n;++i){
    //     if(i<n-1&&a[i]==a[i+1]){
    //         while(i<n-1&&a[i]==a[i+1]) ++i;
    //         cout<<a[i]<<" ";
    //         duplicateFlag = true;
    //     }
    // }
    
    // if(!duplicateFlag) cout<<"-1";
    
    //method 2 : hashing + sorting
    //O(nlogn) time & O(n) space
    // unordered_map<int, int> mp;
    // for(int i=0;i<n;++i) mp[a[i]]++;
    // vector<int> result;
    // for(auto p:mp){
    //     if(p.second>1) result.push_back(p.first);
    // }
    // if(result.size()==0){
    //     cout<<"-1";
    //     return;
    // }
    // sort(result.begin(), result.end());
    // for(int i=0;i<result.size();++i) cout<<result[i]<<" ";
    
    
    //method 3 :
    //O(n) time & O(1) space
    //*** REQUIRED SOLUTION ***
    //since elements are in range  0 to n-1, i can use mathematics
    //trick of rearranging array in O(1) 
    
    int M = n+5; //this number is guaranteed to be greater than any element in array
    
    for(int i=0;i<n;++i){
        int ele = a[i]%M;
        a[ele] += M;
    }
    bool duplicateFlag = false;
    for(int i=0;i<n;++i){
        //cout<<a[i]<<", ";
        if(a[i]>=2*M) {
            cout<<i<<" ";
            duplicateFlag = true;
        }
    }
    if(!duplicateFlag) cout<<"-1";
}


