//1) naive approach
//Merge function used in merge sort
//O(m+n) time & O(m+n) space
void merge(int arr[], int l, int h, int m){
    int size1 = m-l+1;
    int size2 = h-m;
    int arr1[size1];
    int arr2[size2];
    for(int i=0;i<size1;++i){
        arr1[i] = arr[l+i];
    }
    for(int i=0;i<size2;++i){
        arr2[i] = arr[i+m+1];
    }
    int i=0,j=0,k=l;
    while(i<size1&&j<size2){
        if(arr1[i]<=arr2[j]){
            arr[k] = arr1[i];
            ++i;
        }else{
            arr[k] = arr2[j];
            ++j;
        }
        ++k;
    }
    while(i<size1){
        arr[k] = arr1[i];
        ++i;
        ++k;
    }
    while(j<size2){
        arr[k] = arr2[j];
        ++j;
        ++k;
    }
    
}


//2) space efficient approach
//O(m+n) time & O(1) space
//https://www.geeksforgeeks.org/merge-sort-with-o1-extra-space-merge-and-on-lg-n-time/?ref=rp
void merge(int arr[], int l, int m, int r)
{
//naive : O(m+n) time & O(m+n) space
     
     //method 2 : merge 2 sorted arrays in constant time
     //O(m+n) time & O(1) space
     /*
     we will use a mathematics trick to store 2 values at one index
     say we have to store x & y at index i of arr
     then first we have to find an element greater than x & y say z
     then arr[i] = x + y*z, then arr[i]%z will give x &
     arr[i]/z will give y
     */
     //first we have to find an element which is greter than any array element
     int max_num = arr[l];
     for(int i=l;i<=r;++i){
         max_num = max(max_num, arr[i]);
     }
     ++max_num;
     
     int i = l, j = m+1;
     int k = l;     //sorted element index
     while(i<=m&&j<=r){
         //say in our mathematics trick x be original element
         // & y be sorted element & z will be max_num
         int left_original_ele = arr[i]%max_num;
         int right_original_ele = arr[j]%max_num;
         if(left_original_ele<=right_original_ele){
             arr[k] = arr[k] + left_original_ele*max_num;
             ++i;
         }else {
             arr[k] = arr[k] + right_original_ele*max_num;
             ++j;
         }
         ++k;
     }
     
     while(i<=m){
         int original_ele = arr[i]%max_num;
         arr[k] = arr[k] + original_ele*max_num;
         ++i;
         ++k;
     }
     
     
     while(j<=r){
         int original_ele = arr[j]%max_num;
         arr[k] = arr[k] + original_ele*max_num;
         ++j;
         ++k;
     }
     
     for(int i=l;i<=r;++i){
         arr[i] = arr[i]/max_num;
     }
     
}


//*** Interesting fact *** : we have a heap based solution for merge k different sorted array which works better than 
//both of the above solution. : https://github.com/ap0996/ImportantAlgorithms/blob/master/gfg/16)Heap/7)Merge%20K%20Sorted%20Arrays



//**** 2 APPLICATIONS of merge function of mergesort *****
//1) INTERSECTION & UNION OF 2 SORTED ARRAY 
//Naive solution is 0(m*n), aux space 0(1), do it in 0(m+n) time and 0(1) space
//Note:- Hashing Version is used to find intersection & union of 2 arrays( not necessarily sorted) in 0(m+n) time BUT in 0(m) space.
#include <bits/stdc++.h>
using namespace std;

void intersectionOfSortedArrays(int arr1[], int arr2[], int m, int n){
    int i=0,j=0;
    while(i<m&&j<n){
        //skipping duplicates in array 1
        if(i>0&&arr1[i-1]==arr1[i]){
            ++i;
            continue;
        }
        
        if(arr1[i]==arr2[j]){
            cout<<arr1[i]<<" ";
            ++i,++j;
        }else if(arr1[i]<arr2[j]){
            ++i;
        }else if(arr1[i]>arr2[j]){
            ++j;
        } 
    }
    cout<<endl;
}

void unionOfSortedArrays(int arr1[], int arr2[], int m, int n){
    int i=0,j=0;
    while(i<m&&j<n){
        //skipping duplicates in array 1 and array 2
        if(i>0&&arr1[i-1]==arr1[i]){
            ++i;
            continue;
        }
        if(j>0&&arr2[j-1]==arr2[j]){
            ++j;
            continue;
        }
        
        
        if(arr1[i]==arr2[j]){
            cout<<arr1[i]<<" ";
            ++i,++j;
        }else if(arr1[i]<arr2[j]){
            cout<<arr1[i]<<" ";
            ++i;
        }else if(arr1[i]>arr2[j]){
            cout<<arr2[j]<<" ";
            ++j;
        } 
    }
    
    while(i<m){
        if(i>0&&arr1[i-1]==arr1[i]){
            ++i;
            continue;
        }
        cout<<arr1[i]<<" ";
        ++i;
        }
    while(j<n){
        if(j>0&&arr2[j-1]==arr2[j]){
            ++j;
            continue;
        }
        cout<<arr2[j]<<" ";
        ++j;
    }
}

int main()
{
    int arr1[] = {3, 5, 10, 10, 10, 15, 15, 20, 100};
    int arr2[] = {5, 10, 10, 15, 30};

    int m = sizeof(arr1)/sizeof(arr1[0]);
    int n = sizeof(arr2)/sizeof(arr2[0]);
    
    cout<<"intersection: ";
    intersectionOfSortedArrays(arr1, arr2, m, n);
    cout<<"union: ";
    unionOfSortedArrays(arr1, arr2, m, n);
    return 0;
}

//2) COUNT INVERSIONS IN ARRAY
//Naive solution is 0(n^2), do it in 0(nlogn) time
//Approach is based on merge sort. While implementing merge sort total number of inversions is equal:-
//number of inversions in left half + inversions in right half +inversion while merging

#include <bits/stdc++.h>
using namespace std;

int countMergeInversions(int arr[], int l, int h, int m){
    int size1 = m-l+1;
    int size2 = h-m;
    int arr1[size1];
    int arr2[size2];
    for(int i=0;i<size1;++i){
        arr1[i] = arr[l+i];
    }
    for(int i=0;i<size2;++i){
        arr2[i] = arr[i+m+1];
    }
    int i=0,j=0,k=l;
    int mergeCount = 0;
    while(i<size1&&j<size2){
        if(arr1[i]<=arr2[j]){
            arr[k] = arr1[i];
            ++i;
        }else{
            arr[k] = arr2[j];
            ++j;
            mergeCount += size1-i;              //******** important ********
        }
        ++k;
    }
    while(i<size1){
        arr[k] = arr1[i];
        ++i;
        ++k;
    }
    while(j<size2){
        arr[k] = arr2[j];
        ++j;
        ++k;
    }
    return mergeCount;
    
}
int countInversions(int arr[], int l, int h){
    int result = 0;
    if(l<h){
        int m = l +(h-l)/2;
        result += countInversions(arr, l, m);
        result += countInversions(arr, m+1, h);
        result += countMergeInversions(arr, l, h, m);
    }
   return result; 
}
int main()
{
   int arr[] = {40, 30, 20, 10, 4};
   int n = sizeof(arr)/sizeof(arr[0]);
   
   int result = countInversions(arr, 0, n-1);
   cout<<"Number of inversions: "<<result;
   
   return 0;
}


//MERGE SORT FOR LINKED LISTS : https://github.com/ap0996/ImportantAlgorithms/blob/master/gfg/11)%20Linked%20List/MergeSort

