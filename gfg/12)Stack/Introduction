//Linear data structure
//Stack underflow & overflow

//There are 2 ways to implement a stack: Using array & Using linked list(push & pop at head of linked list)

//Note: While using stack, if we look for top() or try to pop() when stack is empty results in segmentation error. Use
// !stack.empty() for safe checking then using top() or pop()

//Stack stl :- satck <data_type> stack_name;
//functions :- empty(), size(), top(), push(g) & pop(). All these functins work in O(1) time.



//APLLICATIONS: Function call stack, reverse, palindrome, balanced paranthesis, infix to pre/postfix, pref/postfix evaluation,
//undo/redo, forward/back, remove consecutive duplicates & STOCK SPAN PROBLEM and its variations

//Application 1): print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the FIRST greater
//element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1.
//Naive is O(n^2), do it in O(n) time & O(n) space(stack in this case)
#include <bits/stdc++.h>
using namespace std;

void nextGreaterElement(int arr[], int size){
    stack <int> st;
    
    st.push(arr[0]);
    for(int i=1;i<size;++i){
        while(!st.empty()&&st.top()<arr[i]){
            cout<<st.top()<<"->"<<arr[i]<<endl;
            st.pop();
        }
        st.push(arr[i]);
    }
    while(!st.empty()){
        cout<<st.top()<<"->"<<"-1"<<endl;
        st.pop();
    }
}

void nextGreaterElementInSameOrder(int arr[], int size){
    //** The next greater elements should be printed in same order as input array **
    stack <int> st;
    int result[size];
    
    for(int i=size-1;i>=0;--i){
        while(!st.empty()&&st.top()<=arr[i]){
            st.pop();
        }
        if(st.empty()) result[i] = -1;
        else result[i] = st.top();
        st.push(arr[i]);
    }
    for(int i=0;i<size;++i) cout<<arr[i]<<"-> "<<result[i]<<endl;
}

int main() {
	int arr[] = { 11, 13, 21, 7 };
	int n = sizeof(arr)/sizeof(arr[0]);
	//nextGreaterElement(arr, n);
	nextGreaterElementInSameOrder(arr, n);
	return 0;
}



//Application 2):
//The task is to create a data structure "twoStacks" that represents two stacks.Implementation of twoStacks should use only one array
//Method 1 (Divide the space in two halves)
//Method 2 (A space-efficient implementation): Both stacks grow (or shrink) in opposite
//direction. To check for overflow, all we need to check is for space between top elements of both stacks.

#include <bits/stdc++.h>
using namespace std;

class twoStacks {
    int *arr;
    int size;
    int top1, top2;
    
    public:
    twoStacks(int n){
        size = n;
        top1 = -1;
        top2 = n;
        arr = new int[size];
        for(int i=0;i<size;++i) arr[i] = -1;
    }
    
    void push1(int x){
        if(top2-top1>1){
            ++top1;
            arr[top1] = x;
        }else{
            cout<<"Stack 1 Overflow!!"<<endl;
        }
    }
    void push2(int x){
        if(top2-top1>1){
            --top2;
            arr[top2] = x;
        }else{
            cout<<"Stack 2 Overflow!!"<<endl;
        }
    }
    void pop1(){
        if(top1>-1){
            arr[top1] = -1;
            --top1;
        }else{
            cout<<"Stack 1 Underflow!!"<<endl;
        }
    }
    void pop2(){
        if(top2<size){
            arr[top2] = -1;
            ++top2;
        }else{
            cout<<"Stack 2 Underflow!!"<<endl;
        }
    }
    
    void displayArray(){
        for(int i=0;i<size;++i) cout<<arr[i]<<"|";
        cout<<endl;
    }  
};

int main() {
    //Implementing 2 stacks using 1 array
    twoStacks ts = twoStacks(5);
    ts.displayArray();
    ts.pop1();
    ts.pop2();
    ts.displayArray();
    ts.push1(12);
    ts.push2(5);
    ts.displayArray();
    ts.push1(4);
    ts.push1(3);
    ts.displayArray();
    ts.push1(99);
    ts.displayArray();  
	return 0;
}

//Application 3): 
//Stacks can be used to remove duplicate characters from a string that are stacked next to each other. 
//For example, we take the string aabbccccc and convert it into abc. We can push the first character into a stack and skip if 
//the top of the stack is equal to current character.
string removeConsecutiveDuplicates(string s)
{
    // Your code here
    stack <char> st;
    for(int i=0;i<s.length();++i){
        if(!st.empty()&&st.top()==s[i]) continue;       //ignoring consecutive duplicates
        else {
            st.push(s[i]);
        }
    }
    stack <char> st2;
    while(!st.empty()){         //using another stack to reverse contents of first stack
        char x = st.top();
        st2.push(x);
        st.pop();
    }
    string result = "";
    while(!st2.empty()){
        result += st2.top();
        st2.pop();
    }
    return result;
}
