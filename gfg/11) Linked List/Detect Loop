//Detect Loop in Singly Linked List
//Method 1) Naive approach: O(n^2)
//for every ith node we check if its next node has same address as one of the 0 to i-1 nodes, If yes then there is a loop.

//Method 2) If modification in linked list structure is allowed, we add a visited flag in linked list definition and if an
//already visited node is again visited then we say linked list has a loop in O(n) time and extra space visited flag on every node
struct Node{
    int key;
    bool visited;
    Node *next;
    Node(int x){
        key = x;
        next = NULL;
        visited = false;
    }
};

//Method 3) In this method instead of modifiying sturcture of linked list , we modify pointers of linked list
//O(n) time and O(1) space, but MODIFIES the linked list(doesn't remains the same).
//Approach: We use a dummy node. while traversing the linked list for every node, after saving the next node point the 
//next pointer of current node to dummy node. And if current node is already pointing to the dummy node, there exists a loop.
//https://drive.google.com/file/d/1b_uT8WSv0RJ4a7Os7-QFKJ_XTBibODd4/view?usp=sharing
bool detectLoop3(Node *head){   //O(n)time & O(1)space
    Node *dummy;
    Node *curr = head;
    while(curr!=NULL){
        //cout<<curr->key<<":";
        if(curr->next == dummy) return true;
        Node *nextNode = curr->next;
        curr->next = dummy;
        curr = nextNode;
        
    }
    return false;
}
//Mehod 4) O(n) time, O(n) space, doesn't modify linked list structure or pointers.
//Use HASHING
bool detectLoop4(Node *head){
    unordered_set<Node *> s;
    Node *temp = head;
    while(temp!=NULL){
        if(s.find(temp)==s.end()) s.insert(temp);
        else return true;
        temp = temp->next;
    }
    return false;
}

//Method 5) O(n) time, O(1) space, doesn't modify linked list structure or pointers
//***FLOYD DETECTION METHOD*** (very popular algo)
//Approach: We maintain 2 pointers i.e slow and fast. If there is a loop in linked list then these 2 will definately meet and if not
//then fast pointer will reach end .
bool floydDetectLoop(Node *head){
    Node *slow = head;
    Node *fast = head;
    while(fast!=NULL&&fast->next!=NULL){
        slow = slow->next;
        fast = fast->next->next;
        if(slow==fast) return true;
    }
    return false;
}



