//Given an array of n elements, where each element is at most k away from its target position,
//devise an algorithm that sorts in O(n log k) time

//Naive approach would be to use insertion sort: O(nk) time
//C++ STL sort() function can sort in O(nlogn) time , But we can yet also optimize it

//Efficient Approach using heaps: O(nlogk) time & O(k) space
//Idea is to create min heap of size k with first k elements from array or create max heap of last k elements from array

#include <bits/stdc++.h>
using namespace std;

void kSorted(int arr[], int n, int k){  //O(nlogk)
    
    //1) Using Min Heap
    priority_queue<int, vector<int>, greater<int>> pq(arr, arr+k);       //Min Heap of size k
    int index = 0;
    for(int i=k;i<n;++i){
        arr[index] = pq.top();  //getMin(): O(1)
        pq.pop();           //extractMin(): O(logk)
        pq.push(arr[i]);    //insert: O(logk)
        ++index;
    }
    while(!pq.empty()){
        arr[index] = pq.top();
        pq.pop();
        ++index;
    }
    
    //2) Using Max Heap
    // priority_queue<int> pq(arr+n-k, arr+n);     //Max Heap of size k 
    // int index = n-1;
    // for(int i=n-k-1;i>=0;--i){
    //     arr[index] = pq.top();
    //     pq.pop();
    //     pq.push(arr[i]);
    //     --index;
    // }
    // while(!pq.empty()){
    //     arr[index] = pq.top();
    //     pq.pop();
    //     --index;
    // }
    
    
    cout<<"Sorted Array: ";
    for(int i=0;i<n;++i) cout<<arr[i]<<", ";
    cout<<endl;
}

int main() {
    
    int arr[] = {9, 8, 7, 18, 19, 11};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 3;
    
    kSorted(arr, n, k);
    
	return 0;
}











