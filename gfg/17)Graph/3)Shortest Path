
/*
The shortest path problem is about finding shortest path between the source point and every other point in the graph.
This problem could be solved easily using (BFS) if all edge weights were (1), but in weighted graph weights can take any value. 
*/
/*
There are different algorithms for finding shortest path BASED ON USE CASES:
1)Unweighted Graph: ( bfs, O(V+E) )
2)Weighted graph with only positive weighted edges: ( Bellmon Ford, O(VE) ) & ( DJikstra's, O(E+VlogV) )
3)Wieghted graph with negative edges as well: ( Floyd–Warshall's, O(V^3) used to find transitive closure of graph)
4)DAG : We can use any of bellmon ford, djikstra & floyd warshall based on use case BUT Solution based on topological sorting
	is more efficient with time O(V+E)
*/




//1)
//Shortest Path in UNWEIGHTED graph
//Hint :- Use BFS, it naturally finds shortest distance path, its the INHERENT NATURE of bfs
//Time: Same as BFS i.e O(V+E)

void shortestPath(vector<int> adj[], int s, int v){      //v: number of vertices named 0 to v-1
    
    bool visited[v];
    for(int i=0;i<v;++i) visited[i] = false;
    
    int shortestDistance[v] = {INT_MAX};
    
    queue<int> q;
    q.push(s);
    visited[s] = true;
    shortestDistance[s] = 0;
    
    while(!q.empty()){
        int t = q.front();
        q.pop();
        //cout<<t<<", ";
        //pushing all unvisited neighbours of current node
        for(int i=0;i<adj[t].size();++i){
            if(visited[adj[t][i]]==false) {
                q.push(adj[t][i]);
                visited[adj[t][i]] = true;
                shortestDistance[adj[t][i]] = shortestDistance[t]+1;
            }
        }
    } 
    
    for(int i=0;i<v;++i) cout<<shortestDistance[i]<<", ";
    cout<<endl;
}


//2) Directed Graphs

//2A) Shortest Path in WEIGHTED DAG only : Topological Sort Based solution
/*
For a general weighted graph, we can calculate single source shortest distances in O(VE) time using Bellman–Ford Algorithm.
For a graph with no negative weights, we can do better and calculate single source shortest distances in O(E + VLogV) time using
Dijkstra’s algorithm. (We will study them in greedy & dp)
Can we do even better for Directed Acyclic Graph (DAG)? We can calculate single source shortest distancesin O(V+E) time for DAGs.
The idea is to use Topological Sorting.
*/
//time: O(V+E)
/*
1) Initialize dist[] = {INF, INF, ….} and dist[s] = 0 where s is the source vertex.
2) Create a toplogical order of all vertices.
3) Do following for every vertex u in topological order.
………..Do following for every adjacent vertex v of u
………………if (dist[v] > dist[u] + weight(u, v))
………………………dist[v] = dist[u] + weight(u, v)
*/          

#include <bits/stdc++.h>
using namespace std;

void addEdge(vector<pair<int, int>> adj[], int v1, int v2, int w){
    adj[v1].push_back(make_pair(v2, w));
}

void bfs_topological_sort(vector<pair<int, int>> adj[],int result[], int v){
    
    int indegree[v] = {0};
    for(int i=0;i<v;++i){
        for(int j=0;j<adj[i].size();++j){
            ++indegree[adj[i][j].first];
        }
    }
    
    
    queue<int> q;
    //pushing all 0 indegree vertices in queue
    for(int i=0;i<v;++i){
        //cout<<i<<": "<<indegree[i]<<endl;
        if(indegree[i]==0) q.push(i);
    }
    
    int index = 0;
    while(!q.empty()){
        int t = q.front();
        q.pop();
        result[index++] = t;
        for(int i=0;i<adj[t].size();++i){
            --indegree[adj[t][i].first];
            if(indegree[adj[t][i].first]==0) q.push(adj[t][i].first);
        }
    }
}

void shortestPathDAG(vector<pair<int, int>> adj[], int v, int s){
    //Step 1: Do topological sort
    //we will use bfs based approach i.e Kahn's Algorithm
    
    int result[v]={-1};      //result of topological sorting stored in this array
    bfs_topological_sort(adj, result, v);
    
    // for(int i=0;i<v;++i) cout<<result[i]<<", ";
    // cout<<endl;
    
    //Step 2: Traverse tropological ordering
    int shortestPath[v];
    for(int i=0;i<v;++i) shortestPath[i] = INT_MAX;
    //initialise distance to 0 of the source node
    //say node 0 is source
    shortestPath[s] = 0;
    for(int u: result){
        for(pair<int, int> v: adj[u]){
            
            if(shortestPath[v.first]>shortestPath[u]+v.second){
                shortestPath[v.first] = shortestPath[u]+v.second;
            }
        }
    }
    
    cout<<"Shortest Path Distance: ";
    for(int i=0;i<v;++i) cout<<shortestPath[i]<<", ";
    cout<<endl;
}

int main() {
    
    int v = 6;
    vector<pair<int, int>> adjacency_list[v];
    addEdge(adjacency_list, 0, 1, 2);
    addEdge(adjacency_list, 1, 2, 3);
    addEdge(adjacency_list, 2, 3, 6);
    addEdge(adjacency_list, 0, 4, 1);
    addEdge(adjacency_list, 4, 5, 4);
    addEdge(adjacency_list, 5, 3, 1);
    addEdge(adjacency_list, 4, 2, 2);
    
    
    shortestPathDAG(adjacency_list, v, 0);
    
    
	return 0;
}


//2B) DJisktra's Algorithm : Find Shortest Path in weighted graphs with only positive edges
/*Algorithm:
1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in shortest path tree, i.e.,
   whose minimum distance from source is calculated and finalized. Initially, this set is empty.
2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value 
   as 0 for the source vertex so that it is picked first.
3) While sptSet doesn’t include all vertices
 ….a) Pick a vertex u which is not there in sptSet and has minimum distance value.
 ….b) Include u to sptSet.
 ….c) Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices. 
      For every adjacent vertex v, if sum of distance value of u (from source) and weight of edge u-v, is less than the distance value
      of v, then update the distance value of v.
*/
/*Important Points:
->We can create a parent array, update the parent array when distance is updated and 
    use it show the shortest path from source to different vertices.
->The code finds shortest distances from source to all vertices. If we are interested only in shortest distance from the source
    to a single target, we can break the for the loop when the picked minimum distance vertex is equal to target
->Time Complexity of the implementation is O(V^2). If the input graph is represented using adjacency list, it can be reduced 
    to O(E log V) with the help of binary heap.
->Dijkstra’s algorithm doesn’t work for graphs with negative weight edges. For graphs with negative weight edges, Bellman–Ford 
    algorithm can be used.
*/


/*There are many different approaches to implement DJikstra's:
1) DJikstra using adjacency matric representation: O(V^2)
https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/

2) DJikstra using adjacency list representation with CUSTOM made min heap : O(ElogV)
https://www.geeksforgeeks.org/dijkstras-algorithm-for-adjacency-list-representation-greedy-algo-8/

3) Djisktra using C++ STL set : O(ElogV)
https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/
The second implementation is time complexity wise better, but is really complex as we have implemented our own priority queue. 
STL provides priority_queue, but the provided priority queue doesn’t support decrease key and delete operations.Above operations 
can be easily implemented by set data structure of c++ STL

4) Djikstra using C++ STL priority_queue : O(ElogV) i.e APPROACH IMPLEMENTED BELOW
https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/
However, the problem is, priority_queue doesn’t support decrease key. To resolve this problem, do not update a key,but insert one 
more copy of it.Whenever distance of a vertex is reduced, we add one more instance of vertex in priority_queue. Even if there are
multiple instances, we only consider the instance with minimum distance and ignore other instances.
*/

//Djikstra using priority_queue
#include <bits/stdc++.h>
using namespace std;

void addEdge(vector<pair<int, int>> adj[], int u, int v, int weight){
    adj[u].push_back(make_pair(v, weight));
    //since graph is undirected
    adj[v].push_back(make_pair(u, weight)); 
}

struct myComp{
    bool operator()(pair<int, int> p1, pair<int, int> p2){
        return p1.first>p2.first;
    }
};

void djikstra(vector<pair<int, int>> adj[], int source, int V){
    priority_queue<pair<int, int>, vector<pair<int, int>>, myComp> pq;      //pair of (distance, vertext)
    pq.push(make_pair(0, source));
    
    int distance[V];
    for(int i=0;i<V;++i) distance[i] = INT_MAX;
    distance[source] = 0;
    
    while(!pq.empty()){
        pair<int, int> u = pq.top();
        pq.pop();
        //update all neighbours of current vertext 'p'
        for(auto v:adj[u.second]){
            if(distance[v.first]>distance[u.second]+v.second){
                distance[v.first] = distance[u.second]+v.second;
                pq.push(make_pair(distance[v.first], v.first));
            }
        }
    }
    
    cout<<"Vertex\tDistance from source"<<endl;
    for(int i=0;i<V;++i) {
        cout<<i<<"\t"<<distance[i]<<endl;
    }
}


int main() {
    
    int v = 9;
    vector<pair<int, int>> adj[v];      //pair of (vertex, weight)
    addEdge(adj, 0, 1, 4); 
    addEdge(adj, 0, 7, 8); 
    addEdge(adj, 1, 2, 8); 
    addEdge(adj, 1, 7, 11); 
    addEdge(adj, 2, 3, 7); 
    addEdge(adj, 2, 8, 2); 
    addEdge(adj, 2, 5, 4); 
    addEdge(adj, 3, 4, 9); 
    addEdge(adj, 3, 5, 14); 
    addEdge(adj, 4, 5, 10); 
    addEdge(adj, 5, 6, 2); 
    addEdge(adj, 6, 7, 1); 
    addEdge(adj, 6, 8, 6); 
    addEdge(adj, 7, 8, 7); 
    
    djikstra(adj, 1, v);
    
	return 0;
}























