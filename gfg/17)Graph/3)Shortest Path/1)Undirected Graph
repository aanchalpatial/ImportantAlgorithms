
/*
The shortest path problem is about finding shortest path between the source point and every other point in the graph.
This problem could be solved easily using (BFS) if all edge weights were (1), but in weighted graph weights can take any value. 
*/
/*
There are different algorithms for finding shortest path BASED ON USE CASES:
1)Unweighted Graph: ( bfs, O(V+E) )
2)Weighted graph with only positive weighted edges: ( Bellmon Ford, O(VE) ) & ( DJikstra's, O(E+VlogV) )
3)Wieghted graph with negative edges as well: ( Floydâ€“Warshall's, O(V^3) used to find transitive closure of graph)
4)DAG : We can use any of bellmon ford, djikstra & floyd warshall based on use case BUT Solution based on topological sorting
	is more efficient with time O(V+E)
*/



//1)
//Shortest Path in UNWEIGHTED graph
//Hint :- Use BFS, it naturally finds shortest distance path, its the INHERENT NATURE of bfs
//Time: Same as BFS i.e O(V+E)

void shortestPath(vector<int> adj[], int s, int v){      //v: number of vertices named 0 to v-1
    
    bool visited[v];
    for(int i=0;i<v;++i) visited[i] = false;
    
    int shortestDistance[v] = {INT_MAX};
    
    queue<int> q;
    q.push(s);
    visited[s] = true;
    shortestDistance[s] = 0;
    
    while(!q.empty()){
        int t = q.front();
        q.pop();
        //cout<<t<<", ";
        //pushing all unvisited neighbours of current node
        for(int i=0;i<adj[t].size();++i){
            if(visited[adj[t][i]]==false) {
                q.push(adj[t][i]);
                visited[adj[t][i]] = true;
                shortestDistance[adj[t][i]] = shortestDistance[t]+1;
            }
        }
    } 
    
    for(int i=0;i<v;++i) cout<<shortestDistance[i]<<", ";
    cout<<endl;
}
