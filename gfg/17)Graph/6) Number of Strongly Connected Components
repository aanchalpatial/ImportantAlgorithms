//A graph is strongly connected if there is a path between all pairs of vertices.


//1) 
Finding Strongly connected components of an UNDIRECTED graph
/*Finding connected components for an undirected graph is an easier task. We simple need to do either BFS or DFS starting from
every unvisited vertex, and we get all strongly connected components.
*/
void dfs(){}

int dfsDisconnected(vector<int> adj[], int v){
  bool visited[v] = {false};
  
  int connectedComponentsCount = 0;
  
  for(int i=0;i<v;++i){
    if(visited[i] == false){
      ++connectedComponentsCount;
      //cout<<" Strongly Connected Component "<<connectedComponentsCount<<" : ";
      DFS(adj, visited, 0, v);
      cout<<endl;
      }
    }
   return connectedComponentsCount;
  }

//1A)
APPLICATION OF ABOVE ALGORITHM: *** NUMBER OF ISLANDS *** 
/*This problem is also famously known as: Find the number of ISLANDS
Given a boolean 2D matrix, find the number of islands. A group of connected 1s forms an island. For example:
1 1 0
0 0 1
1 0 1
Here, two islands will be formed
First island will be formed by elements {A[0][0] ,  A[0][1], A[1][2], A[2][2]}
Second island will be formed by {A[2][0]}.
*/
void DFS(vector<int> A[], vector<bool> visited[], int N, int M, int r, int c){
    
    visited[r][c] = true;
    
    int rowNbr[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };
    int colNbr[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };
    
    
    //traversing 8 neighbours of a cell in 2D matrix
    for(int i=0;i<8;++i){
        int rr = r+rowNbr[i];
        int cc = c+colNbr[i];
        if((rr>=0&&rr<N)&&(cc>=0&&cc<M)){
            if(A[rr][cc]==1&&visited[rr][cc]==false){
                DFS(A, visited, N, M, rr, cc);
            }   
        }
    }
    
    
}
int findIslands(vector<int> A[], int N, int M) {

    // Your code here
    vector<bool> visited[N];
    
    for(int i=0;i<N;++i){
        for(int j=0;j<M;++j){
            visited[i].push_back(false);
        }
    }
    
    int result = 0;     //number of islands
    
    for(int i=0;i<N;++i){
        for(int j=0;j<M;++j){
            if(A[i][j]==1&&visited[i][j]==false){
                DFS(A, visited, N, M, i, j);
                ++result;
            }
        }
    }
    
    return result;
}


//1B) : LEETCODE 547
/*
There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. 
For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined
a friend circle is a group of students who are direct or indirect friends.

Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth 
students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among
all the students.
*/
class Solution {
public:
    
    void dfs(vector<vector<int>>& M, vector<bool> &visited, int r, int n){
        
        visited[r] = true;
        
        for(int c=0;c<n;++c){
            
            if(M[r][c]==1&&visited[c]==false){
                dfs(M, visited, c, n);
            }
            
        }
        
        
    }
    
    
    int findCircleNum(vector<vector<int>>& M) {
        
        int n = M.size();
        
        //method 1 : connected components using dfs
        //we only need to consider cells above the primary diagonal
        int count = 0;
        vector<bool> visited(n, false);
        
        for(int i=0;i<n;++i){
            if(visited[i]==false){
                dfs(M, visited, i, n);
                ++count;
            }
        }
        return count;
        
        
        
        //method 2 : union-find
        //https://github.com/ap0996/ImportantAlgorithms/edit/master/gfg/24)Disjoint%20Set/1)Introduction
        
    }
};



//1C)
//ANOTHER APPLICATION: Find whether path exist
/*
Given a N X N matrix (M) filled with 1, 0, 2, 3. The task is to find whether there is a path possible from source to destination,
while traversing through blank cells only. You can traverse up, down, right and left.
A value of cell 1 means Source.
A value of cell 2 means Destination.
A value of cell 3 means Blank cell.
A value of cell 0 means Blank Wall.
Note: there is only single source and single destination.
*/
#include<bits/stdc++.h>
using namespace std;

bool DFS(vector<int> A[], vector<bool> visited[], int N, int r, int c){
    
    //cout<<"("<<r<<","<<c<<")  ";
    if(A[r][c]==2) return true;
    else if(A[r][c]==0) return false;
    
    visited[r][c] = true;
    
    int rowNbr[4] = {-1, 0,0, 1};
    int colNbr[4] = { 0,-1,1, 0,};
    
    
    //traversing 4 neighbours(up, down, left & right) of a cell in 2D matrix
    for(int i=0;i<8;++i){
        int rr = r+rowNbr[i];
        int cc = c+colNbr[i];
        if((rr>=0&&rr<N)&&(cc>=0&&cc<N)){
            if((A[rr][cc]==3||A[rr][cc]==2)&&visited[rr][cc]==false){
                if(DFS(A, visited, N, rr, cc)) return true;
            }
            
        }
    }
    return false;
    
}
bool findPath(vector<int> A[], int N) {

    // Your code here
    vector<bool> visited[N];
    
    for(int i=0;i<N;++i){
        for(int j=0;j<N;++j){
            visited[i].push_back(false);
        }
    }
    
    for(int i=0;i<N;++i){
        for(int j=0;j<N;++j){
            if(A[i][j]==1) {
                return DFS(A, visited, N, i, j);
            }
        }
    }
    
}

int main()
 {
	int T;
	cin>>T;
	for(int j=0;j<T;++j){
	    int n;
	    cin>>n;
	    vector<int> adj[n];
	    for(int i=0;i<n;++i){
	        for(int j=0;j<n;++j) {
	            int x;
	            cin>>x;
	            adj[i].push_back(x);
	        }
	    }
	    if(findPath(adj, n)) cout<<"1"<<endl;
	    else cout<<"0"<<endl;
	    
	}
	return 0;
}




//2)
//Finding Strongly connected components of an DIRECTED graph
//There are 2 different algorithms available: 
//2A) Kosaraju's algorithm O(V+E) , 2 dfs traversals	: dfs then reverse then dfs
/*Algorithm:-
1) Create an empty stack ‘S’ and do DFS traversal of a graph. In DFS traversal, after calling recursive DFS for adjacent vertices
   of a vertex, push the vertex to stack. In the above graph, if we start DFS from vertex 0, we get vertices in stack as 1, 2, 4, 3, 0.
2) Reverse directions of all arcs to obtain the transpose graph.
3) One by one pop a vertex from S while S is not empty. Let the popped vertex be ‘v’. Take v as source and do DFS (call DFSUtil(v)). 
   The DFS starting from v prints strongly connected component of v. In the above example, we process vertices in 
   order 0, 3, 4, 2, 1 (One by one popped from stack).
*/
/*Why Kosaraju's Algo works?
DFS may produce a tree or a forest when there are more than one SCCs depending upon the chosen starting point.
To find and print all SCCs, we would want to start DFS from vertex 4 (which is a sink vertex), then move to 3 which is sink in
the remaining set (set excluding 4) and finally any of the remaining vertices (0, 1, 2).
So how do we find this sequence of picking vertices as starting points of DFS?
Solution: So if we do a DFS of the reversed graph using sequence of vertices in stack, we process vertices from sink to
source (in reversed graph). That is what we wanted to achieve and that is all needed to print SCCs one by one.
*/
#include <bits/stdc++.h>
using namespace std;

void addEdge(vector<int> adj[], int u, int v){
    adj[u].push_back(v);
}

void dfsPush(vector<int> adj[], bool visited[], int s, stack<int> &st){
    visited[s] = true;
    for(auto v:adj[s]){
        if(visited[v]==false){
            dfsPush(adj, visited, v, st);
        }
    }
    st.push(s);
}
void dfsPrint(vector<int> adj[], bool visited[], int s){
    cout<<s<<" ";
    visited[s] = true;
    for(auto v:adj[s]){
        if(visited[v]==false){
            dfsPrint(adj, visited, v);
        }
    }
}

void stronglyConnectedComponentsDirectedGraph(vector<int> adj[], int v){
    stack<int> st;
    
    //Step 1: dfs
    bool visited[v] = {false};
    for(int i=0;i<v;++i){
        if(visited[i]==false){
            dfsPush(adj, visited, i, st);
        }
    }
    
    //Step 2: Reverse directed graph
    vector<int> adjr[v];
    for(int i=0;i<v;++i){
        for(int j=0;j<adj[i].size();++j){
            adjr[adj[i][j]].push_back(i);
        }
    }
    
    //Step 3: dfs while popping
    bool visited2[v] = {false};
    while(!st.empty()){
        int u = st.top();
        st.pop();
        if(visited2[u]==false){
            dfsPrint(adjr, visited2, u);
            cout<<endl;
        }
    }
}

int main() {
    
    int v = 5;
    vector<int> adj[v];
    addEdge(adj, 0, 2);
    addEdge(adj, 0, 3);
    addEdge(adj, 1, 0);
    addEdge(adj, 2, 1);
    addEdge(adj, 3, 4);
    
    stronglyConnectedComponentsDirectedGraph(adj, v);
    
    
	return 0;
}


//2B) Tarjan's algorithm  O(V+E) , 1 dfs traversal
//LEFT !!



