//Spanning Tree: Prim's & Kruskal Algorithms
//Shortest Path: Bellmon Ford, DJikstra's & Floyd Warshall
//Strongly connected components in DIRECTED graph


//1) Count the total number of ways or paths that exist between two vertices in a directed graph. These paths doesn’t contain a cycle.
// Function to find paths between 2 nodes
int cnt;
void dfs(list<int> A[], int s, int d, bool visited[]){
    
    if(s==d) {
        ++cnt;
        return;
    }
    //cout<<s<<", ";
    visited[s] = true;

    for(auto u: A[s]){
        if(visited[u]==false){
            dfs(A,u, d, visited);
        }
    }
    visited[s] = false;     //imp step
}

int Graph::countPaths(int s, int d) {
    // Your code here
    cnt = 0;
    bool visited[V] = {false};
    
    dfs(adj,s,d,visited);
    return cnt;
    
}


//2) Minimum time required to rot all oranges
#include<bits/stdc++.h>
using namespace std;


int timeToRot(vector<int> adj[], int n, int m){
    //bfs is suitable for this question
    
    queue<pair<int, int>> q;
    for(int i=0;i<n;++i){
        for(int j=0;j<m;++j){
            if(adj[i][j]==2) q.push(make_pair(i,j));
        }
    }
    int rowNbr[] = {-1, 1, 0, 0};
    int colNbr[] = {0, 0, -1, 1};
    int time = 0;
    while(!q.empty()){
        ++time;
        int cnt = q.size();
        for(int i=0;i<cnt;++i){
            pair<int, int> p = q.front();
            q.pop();
            int r = p.first;
            int c = p.second;
            //checking all four neighbours
            for(int j=0;j<4;++j){
                int rr = r+rowNbr[j];
                int cc = c+colNbr[j];
                if( (rr>=0&&rr<n)&&(cc>=0&&cc<m)&&(adj[rr][cc]==1) ) {
                    adj[rr][cc] = 2;
                    q.push(make_pair(rr,cc));
                }
            }
        }
    }
    for(int i=0;i<n;++i){
        for(int j=0;j<m;++j){
            if(adj[i][j]==1) return -1;
        }
    }
    return time-1;
}
int main()
 {
	int T;
	cin>>T;
	for(int j=0;j<T;++j){
	    int n, m;
	    cin>>n>>m;
	    vector<int> adj[n];
	    for(int i=0;i<n;++i){
	        for(int j=0;j<m;++j){
	            int x;
	            cin>>x;
	            adj[i].push_back(x);
	        }
	    }
	    
	    int result = timeToRot(adj, n, m);
	    cout<<result<<endl;
	}
	return 0;
}

//3) Given an array of N distinct elements A[ ]. The task is to find the minimum number of swaps required to sort the array
/*
This can be easily done by visualizing the problem as a graph. We will have n nodes and an edge directed from node i to node j if
`the element at i’th index must be present at j’th index in the sorted array. The graph will now contain many non-intersecting cycles. 
Now a cycle with 2 nodes will only require 1 swap to reach the correct ordering, similarly a cycle with 3 nodes will only require 
2 swap to do so.
Hence,
ans = Σi = 1tok(cycle_size – 1), where k is the number of cycles
IN OTHER WORDS,
The idea is to create a vector of pair in C++ with first element as array values and second element as array indices. The next step 
is to sort the vector of pair according to the first element of the pair. After that traverse the vector and check if the 
index mapped with the value is correct or not, if not then keep swapping until the element is placed correctly and keep 
counting the number of swaps.
*/

int minSwaps(int A[], int N){
    /*Your code here */
    vector<pair<int, int>> v;
    for(int i=0;i<N;++i){
        v.push_back(make_pair(A[i], i));
    }
    
    sort(v.begin(), v.end());
    
    bool visited[N] = {false};
    
    
    int result = 0;
    
    for(int i=0;i<N;++i){
        
        int j = v[i].second;
        
        if(visited[i]==true||i==j) continue;
        visited[i] = true;
        
        int cycleSize = 0;
        while(!visited[j]){
            ++cycleSize;
            visited[j] = true;
            j = v[j].second;
        }
        result += cycleSize;
	
    }
    return result;
}

//4)Given a square chessboard of N x N size, the position of Knight and position of a target is given. We need to find out
//minimum steps a Knight will take to reach the target position.


