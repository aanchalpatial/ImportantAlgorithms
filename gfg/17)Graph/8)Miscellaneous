//Algorithms not studied.
//Spanning Tree: Kruskal Algorithm
//Shortest Path: Bellmon Ford& Floyd Warshall
//Strongly Connected Components: Tarjan's Algorithm


//Miscellaneous Questions
//1) Count the total number of ways or paths that exist between two vertices in a directed graph. These paths doesn’t contain a cycle.
// Function to find paths between 2 nodes
int cnt;
void dfs(list<int> A[], int s, int d, bool visited[]){
    
    if(s==d) {
        ++cnt;
        return;
    }
    //cout<<s<<", ";
    visited[s] = true;

    for(auto u: A[s]){
        if(visited[u]==false){
            dfs(A,u, d, visited);
        }
    }
    visited[s] = false;     //imp step
}

int Graph::countPaths(int s, int d) {
    // Your code here
    cnt = 0;
    bool visited[V] = {false};
    
    dfs(adj,s,d,visited);
    return cnt;
    
}


//2) Minimum time required to rot all oranges
#include<bits/stdc++.h>
using namespace std;


int timeToRot(vector<int> adj[], int n, int m){
    //bfs is suitable for this question
    
    queue<pair<int, int>> q;
    for(int i=0;i<n;++i){
        for(int j=0;j<m;++j){
            if(adj[i][j]==2) q.push(make_pair(i,j));
        }
    }
    int rowNbr[] = {-1, 1, 0, 0};
    int colNbr[] = {0, 0, -1, 1};
    int time = 0;
    while(!q.empty()){
        ++time;
        int cnt = q.size();
        for(int i=0;i<cnt;++i){
            pair<int, int> p = q.front();
            q.pop();
            int r = p.first;
            int c = p.second;
            //checking all four neighbours
            for(int j=0;j<4;++j){
                int rr = r+rowNbr[j];
                int cc = c+colNbr[j];
                if( (rr>=0&&rr<n)&&(cc>=0&&cc<m)&&(adj[rr][cc]==1) ) {
                    adj[rr][cc] = 2;
                    q.push(make_pair(rr,cc));
                }
            }
        }
    }
    for(int i=0;i<n;++i){
        for(int j=0;j<m;++j){
            if(adj[i][j]==1) return -1;
        }
    }
    return time-1;
}
int main()
 {
	int T;
	cin>>T;
	for(int j=0;j<T;++j){
	    int n, m;
	    cin>>n>>m;
	    vector<int> adj[n];
	    for(int i=0;i<n;++i){
	        for(int j=0;j<m;++j){
	            int x;
	            cin>>x;
	            adj[i].push_back(x);
	        }
	    }
	    
	    int result = timeToRot(adj, n, m);
	    cout<<result<<endl;
	}
	return 0;
}

//3) Given an array of N distinct elements A[ ]. The task is to find the minimum number of swaps required to sort the array
/*
This can be easily done by visualizing the problem as a graph. We will have n nodes and an edge directed from node i to node j if
`the element at i’th index must be present at j’th index in the sorted array. The graph will now contain many non-intersecting cycles. 
Now a cycle with 2 nodes will only require 1 swap to reach the correct ordering, similarly a cycle with 3 nodes will only require 
2 swap to do so.
Hence,
ans = Σi = 1tok(cycle_size – 1), where k is the number of cycles
IN OTHER WORDS,
The idea is to create a vector of pair in C++ with first element as array values and second element as array indices. The next step 
is to sort the vector of pair according to the first element of the pair. After that traverse the vector and check if the 
index mapped with the value is correct or not, if not then keep swapping until the element is placed correctly and keep 
counting the number of swaps.
*/

int minSwaps(int A[], int N){
    /*Your code here */
    vector<pair<int, int>> v;
    for(int i=0;i<N;++i){
        v.push_back(make_pair(A[i], i));
    }
    
    sort(v.begin(), v.end());
    
    bool visited[N] = {false};
    
    
    int result = 0;
    
    for(int i=0;i<N;++i){
        
        int j = v[i].second;
        
        if(visited[i]==true||i==j) continue;
        visited[i] = true;
        
        int cycleSize = 0;
        while(!visited[j]){
            ++cycleSize;
            visited[j] = true;
            j = v[j].second;
        }
        result += cycleSize;
	
    }
    return result;
}

//4)
/*Given a square chessboard of N x N size, the position of Knight and position of a target is given. We need to find out
minimum steps a Knight will take to reach the target position.
The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case contains
an integer n denoting the size of the square chessboard. The next line contains the X-Y coordinates of the knight. The next line 
contains the X-Y coordinates of the target. 
*/
//Note:- We have to convert X-Y co-ordinate to matrix index for input of knight & target
#include<bits/stdc++.h>
using namespace std;

int minimumStepToCapture(pair<int, int> knight, pair<int, int> target, int n){
    bool visited[n+1][n+1];
    for(int i=0;i<n+1;++i){
        for(int j=0;j<n+1;++j){
            visited[i][j] = false;
        }
    }
    
    int rowNbr[] = {-2, -1, 1, 2, -2, -1, 1, 2};
    int colNbr[] = {1, 2, 2, 1, -1, -2, -2, -1};
    queue<pair<int, int>> q;
    q.push(knight);
    visited[knight.first][knight.second] = true;
    
    int steps = 0;
    while(!q.empty()){
        int cnt = q.size();
        for(int i=0;i<cnt;++i){
            pair<int, int> cell = q.front();
            q.pop();
            if(cell.first==target.first&&cell.second==target.second) return steps;
            for(int i=0;i<8;++i){
                int r = cell.first+rowNbr[i];
                int c = cell.second+colNbr[i];
                if( (r>=0&&r<n)&&(c>=0&&c<n)&&visited[r][c]==false ) {
                    q.push(make_pair(r,c));
                    visited[r][c]=true;
                }
            }
        }
        ++steps;

    }
    
}

int main()
 {
	int T;
	cin>>T;
	for(int j=0;j<T;++j){
	    int n;
	    cin>>n;
	    pair<int, int> knight;
	    pair<int, int> target;
	    int p,q,r,s;
	    cin>>p>>q>>r>>s;
	    //converting x-y co-ordinates to matrix indexes
	    knight = make_pair(n-q,p-1);    
	    target = make_pair(n-s,r-1);
	    
	    int result = minimumStepToCapture(knight, target, n);
	    cout<<result<<endl;
	}
	return 0;
}


//5) Multi Source BFS
/*Given a binary matrix of size N x M. The task is to find the distance of nearest 1 in the matrix for each cell. The distance is 
calculated as |i1 – i2| + |j1 – j2|, where i1, j1 are the row number and column number of the current cell and i2, j2 are the row
number and column number of the nearest cell having value 1.
*/
void nearest(vector<vector<int>> arr, int row, int col) {

    //multi source bfs
    int rowNbr[] = {-1,0,1,0};
    int colNbr[] = {0,1,0,-1};
    
    queue<pair<int, int>> q;
    
    int distance[row][col];
    bool visited[row][col];
    for(int i=0;i<row;++i){
        for(int j=0;j<col;++j){
            visited[i][j] = false;
        }
    }
    
    //pushing all cell with 1
    for(int i=0;i<row;++i){
        for(int j=0;j<col;++j){
            if(arr[i][j]==1){
                q.push(make_pair(i,j));
                distance[i][j] = 0;
                visited[i][j] = true;
            }else distance[i][j] = INT_MAX;
        }
    }
    
    int dist;
    while(!q.empty()){
        
            pair<int, int> cell = q.front();
            q.pop();
            dist = distance[cell.first][cell.second];
            //visited[cell.first][cell.second] = true;
            for(int i=0;i<4;++i){
                int r = cell.first+rowNbr[i];
                int c = cell.second+colNbr[i];
                
                if( r>=0&&r<row&&c>=0&&c<col&&visited[r][c]==false){
                    distance[r][c] = min(distance[r][c], dist+1);
                    visited[r][c] = true;
                    q.push(make_pair(r,c));
                }
            } 
    }

    for(int i=0;i<row;++i){
        for(int j=0;j<col;++j){
            cout<<distance[i][j]<<" ";
        }
    }
    cout<<endl;
}





