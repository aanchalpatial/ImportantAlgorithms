/* Given a set of coin values {c1,c2,...,ck} and a sum of money x, our task is to form the sum x 
using as few coins as possible.The greedy algorithm does not necessarily produce an optimal solution.*/

#include<bits/stdc++.h>
using namespace std;

int arr[3]={1,3,4};             //available coins
int d[100]; 
//The constant N(100 in our case) has to be chosen so that all required values of the function fit in the array.
int e[100];
// The new array indicates for each sum of money the first coin that should be chosen in an optimal solution

int smallestNumberOfCoins(int x)
{   
    int result = 10e6;       //The code assumes 10^6 denotes infinity.
    if(x<0) return 10e6;
    if(x==0) return 0;
    if(d[x] != -1){ return d[x];}
    else {
        for(int i=0;i<3;++i){
            int result2 = smallestNumberOfCoins(x-arr[i])+1;
            if(result2 < result) e[x] = arr[i];
            result = min(result,result2);}
    }
    d[x] = result;
    return d[x];
    
}
int main(){
    
    memset(d, -1, sizeof(d));
    
    
    int sum = 22;
    
    //for(int i=0;i<11;++i){
        cout<<"f("<<sum<<") = "<<smallestNumberOfCoins(sum)<<"\n";
        /*Sometimes we are asked both to find the value of an optimal solution 
        and also to give an example how such a solution can be CONSTRUCTED.*/
        cout<<"coins that produce the sum : "<<sum<<"\n";
        //int sum = i;
        while(sum>0){
            cout<<"->"<<e[sum];
            sum -= e[sum];
        }
        cout<<endl;
    //}
    
    return 0;
}

//The time complexity of the resulting algorithm is O(xk) where the sum is x and the number of coins is k.
